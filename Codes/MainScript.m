% F1 and F2 are the two fundamental frequencies present in the signal
F1 = 140;
F2 = 148.3;

Fs = 22050; % sampling frequency
T = 0.0464; % 46.4 ms

t = 0 : 1/Fs : T;

signal = sin(2*pi*F1*t) + sin(2*pi*F2*t);
% This signal is just a sum of two sinusoids with different fundamental frequency

input_signal = awgn(signal, 2.2); % adds white Gaussian noise with signal-to-noise ratio 2.2dB
% This is the input signal for our model

figure(1);
subplot(2,1,1);
plot(t, input_signal);
xlabel("t"); ylabel("x(t)");
title("Input signal (sum of sinusoids + white gaussian noise)");
grid on;

wn = hamming(1024); % hamming window of 1024 samples

windowed_signal = input_signal .* transpose(wn);


subplot(2,1,2);
plot(t, windowed_signal);
xlabel("t"); ylabel("x(t)");
title("Input signal (signal + white gaussian noise) after windowing");
grid on;

% The highpass and the lowpass filters used in the next few steps are
% designed using 'filterDesigner'. And the functions that implement these
% filters are generated by MATLAB.
% These functions return the details of the filters, of which 'sosMatrix'
% is a vector that contains the filter coefficients.
% The first half of sosMatrix is the coefficient vector of numerator and
% the second half of sosMatrix is the coefficient vector of the denominator

Hd = Highpass; % Highpass returns the filter coefficients of the high-pass filter
% we then use these coefficients to filter the signal
x_high = filter(Hd.sosMatrix(1:length(Hd.sosMatrix)/2), Hd.sosMatrix(1 + length(Hd.sosMatrix)/2 : length(Hd.sosMatrix)), windowed_signal);

figure(2);
subplot(2,1,1);
plot(t, x_high);
xlabel("t"); ylabel("x_{high}");
title("High channel");
grid on;

LP = Lowpass; % Lowpass returns the filter coefficients of the low-pass filter
% we then use these coefficients to filter the signal
x_low = filter(LP.sosMatrix(1:length(LP.sosMatrix)/2), LP.sosMatrix(1 + length(LP.sosMatrix)/2 : length(LP.sosMatrix)), windowed_signal);

subplot(2,1,2);
plot(t, x_low);
xlabel("t"); ylabel("x_{low}");
title("Low channel");
grid on;

% Half-wave rectifying the high channel signal
x_high = HalfWaveRectifier(x_high);

figure(3);
subplot(2,1,1);
plot(t, x_high);
xlabel("t"); ylabel("x_{high}");
title("High channel after half-wave rect.");
grid on;

% lowpass filter the rectified high channel signal
x_high = filter(LP.sosMatrix(1:length(LP.sosMatrix)/2), LP.sosMatrix(1 + length(LP.sosMatrix)/2 : length(LP.sosMatrix)), x_high);

subplot(2,1,2);
plot(t, x_high);
xlabel("t"); ylabel("x_{high}");
title("High channel after half-wave rect. and lowpass filtering");
grid on;

SACF = PeriodicityDetection(x_low, x_high, 0.67); % the third parameter here is the value of k
% In normal autocorrelation, k = 2. But here we observe that k = 0.67 gives the best result.

figure(4);
subplot(2,1,1);
plot(t, SACF);
xlabel("lag"); ylabel("SACF");
xlim([0 0.02]);
title("Summary Auto Correlation Function");
grid on;

% SACFenhancer is a function where we process the SACF and remove the false peaks
ESACF = SACFenhancer(SACF);

subplot(2,1,2);
plot(t, ESACF);
xlabel("lag"); ylabel("ESACF");
xlim([0 0.02]);
title("Enhanced Summary Auto Correlation Function");
grid on;